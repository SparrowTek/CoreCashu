//
//  NUT17.swift
//  CashuKit
//
//  NUT-17: WebSockets
//  https://github.com/cashubtc/nuts/blob/main/17.md
//

import Foundation

// MARK: - NUT-17: WebSockets

/// NUT-17: WebSockets
/// This NUT defines a websocket protocol for bidirectional communication between apps and mints using JSON-RPC

// MARK: - JSON-RPC Types

/// JSON-RPC version constant
public let jsonRPCVersion = "2.0"

/// WebSocket request methods
public enum WsRequestMethod: String, CaseIterable, CashuCodabale {
    case subscribe = "subscribe"
    case unsubscribe = "unsubscribe"
    
    public var description: String {
        switch self {
        case .subscribe:
            return "Subscribe to updates"
        case .unsubscribe:
            return "Unsubscribe from updates"
        }
    }
}

/// Subscription kinds for different update types
public enum SubscriptionKind: String, CaseIterable, CashuCodabale {
    case bolt11MeltQuote = "bolt11_melt_quote"
    case bolt11MintQuote = "bolt11_mint_quote"
    case proofState = "proof_state"
    
    public var description: String {
        switch self {
        case .bolt11MeltQuote:
            return "Lightning melt quote updates"
        case .bolt11MintQuote:
            return "Lightning mint quote updates"
        case .proofState:
            return "Proof state updates"
        }
    }
}

// MARK: - Request Parameters

/// Parameters for subscribe command
public struct WsSubscribeParams: CashuCodabale {
    /// Type of subscription
    public let kind: SubscriptionKind
    
    /// Unique subscription ID generated by wallet
    public let subId: String
    
    /// Array of IDs to filter (quote IDs or Y values)
    public let filters: [String]
    
    public init(kind: SubscriptionKind, subId: String, filters: [String]) {
        self.kind = kind
        self.subId = subId
        self.filters = filters
    }
}

/// Parameters for unsubscribe command
public struct WsUnsubscribeParams: CashuCodabale {
    /// Subscription ID to unsubscribe
    public let subId: String
    
    public init(subId: String) {
        self.subId = subId
    }
}

// MARK: - Request/Response Types

/// WebSocket request from wallet to mint
public struct WsRequest: CashuCodabale {
    /// JSON-RPC version
    public let jsonrpc: String
    
    /// Request method
    public let method: WsRequestMethod
    
    /// Request parameters (serialized JSON string)
    public let params: String
    
    /// Request ID (incrementing integer)
    public let id: Int
    
    public init(method: WsRequestMethod, params: String, id: Int) {
        self.jsonrpc = jsonRPCVersion
        self.method = method
        self.params = params
        self.id = id
    }
    
    /// Create a subscribe request
    public static func subscribe(
        kind: SubscriptionKind,
        subId: String,
        filters: [String],
        id: Int
    ) throws -> WsRequest {
        let params = WsSubscribeParams(kind: kind, subId: subId, filters: filters)
        let paramsData = try JSONEncoder().encode(params)
        let paramsString = String(data: paramsData, encoding: .utf8) ?? "{}"
        
        return WsRequest(
            method: .subscribe,
            params: paramsString,
            id: id
        )
    }
    
    /// Create an unsubscribe request
    public static func unsubscribe(subId: String, id: Int) throws -> WsRequest {
        let params = WsUnsubscribeParams(subId: subId)
        let paramsData = try JSONEncoder().encode(params)
        let paramsString = String(data: paramsData, encoding: .utf8) ?? "{}"
        
        return WsRequest(
            method: .unsubscribe,
            params: paramsString,
            id: id
        )
    }
}

/// WebSocket response result
public struct WsResponseResult: CashuCodabale {
    public let status: String
    public let subId: String
    
    public init(status: String, subId: String) {
        self.status = status
        self.subId = subId
    }
}

/// WebSocket response from mint to wallet
public struct WsResponse: CashuCodabale {
    /// JSON-RPC version
    public let jsonrpc: String
    
    /// Response result
    public let result: WsResponseResult?
    
    /// Error if any
    public let error: WsError?
    
    /// Corresponding request ID
    public let id: Int
    
    public init(result: WsResponseResult? = nil, error: WsError? = nil, id: Int) {
        self.jsonrpc = jsonRPCVersion
        self.result = result
        self.error = error
        self.id = id
    }
    
    /// Check if response indicates success
    public var isSuccess: Bool {
        return result?.status == "OK" && error == nil
    }
}

/// WebSocket error structure
public struct WsError: CashuCodabale, Error {
    public let code: Int
    public let message: String
    
    public init(code: Int, message: String) {
        self.code = code
        self.message = message
    }
}

// MARK: - Notification Types

/// Notification parameters
public struct WsNotificationParams: CashuCodabale {
    /// Subscription ID this notification corresponds to
    public let subId: String
    
    /// Payload data (as dictionary for flexibility)
    public let payload: AnyCodable
    
    public init(subId: String, payload: AnyCodable) {
        self.subId = subId
        self.payload = payload
    }
}

/// WebSocket notification from mint to wallet
public struct WsNotification: CashuCodabale {
    /// JSON-RPC version
    public let jsonrpc: String
    
    /// Method (always "subscribe" for notifications)
    public let method: String
    
    /// Notification parameters
    public let params: WsNotificationParams
    
    public init(params: WsNotificationParams) {
        self.jsonrpc = jsonRPCVersion
        self.method = "subscribe"
        self.params = params
    }
}

// MARK: - WebSocket Message Types

/// Enum representing all possible WebSocket messages
public enum WsMessage: Sendable {
    case request(WsRequest)
    case response(WsResponse)
    case notification(WsNotification)
    case error(any Error)
    
    /// Decode a WebSocket message from JSON data
    public static func decode(from data: Data) throws -> WsMessage {
        let decoder = JSONDecoder()
        
        // Try to decode as response first (has result or error field)
        if let response = try? decoder.decode(WsResponse.self, from: data) {
            return .response(response)
        }
        
        // Try to decode as notification (has method = "subscribe" and params)
        if let notification = try? decoder.decode(WsNotification.self, from: data) {
            return .notification(notification)
        }
        
        // Try to decode as request
        if let request = try? decoder.decode(WsRequest.self, from: data) {
            return .request(request)
        }
        
        throw CashuError.deserializationFailed
    }
}

// MARK: - WebSocket Client

/// WebSocket client for NUT-17 communication
@available(iOS 13.0, macOS 10.15, *)
public actor WebSocketClient {
    /// WebSocket task
    private var webSocketTask: URLSessionWebSocketTask?
    
    /// URL session
    private let session: URLSession
    
    /// WebSocket URL
    private let url: URL
    
    /// Active subscriptions
    private var subscriptions: [String: WsSubscription] = [:]
    
    /// Request ID counter
    private var requestIdCounter = 0
    
    /// Message stream
    private var messageStream: AsyncThrowingStream<WsMessage, any Error>?
    private var messageContinuation: AsyncThrowingStream<WsMessage, any Error>.Continuation?
    
    public init(url: URL, session: URLSession = .shared) {
        self.url = url
        self.session = session
    }
    
    /// Connect to the WebSocket
    public func connect() async throws {
        guard webSocketTask == nil else { return }
        
        webSocketTask = session.webSocketTask(with: url)
        webSocketTask?.resume()
        
        // Create message stream
        let (stream, continuation) = AsyncThrowingStream<WsMessage, any Error>.makeStream()
        self.messageStream = stream
        self.messageContinuation = continuation
        
        // Start receiving messages
        Task {
            await receiveMessages()
        }
    }
    
    /// Disconnect from the WebSocket
    public func disconnect() async {
        webSocketTask?.cancel(with: .normalClosure, reason: nil)
        webSocketTask = nil
        messageContinuation?.finish()
        messageContinuation = nil
        messageStream = nil
        subscriptions.removeAll()
    }
    
    /// Send a request
    public func send(_ request: WsRequest) async throws {
        guard let webSocketTask = webSocketTask else {
            throw CashuError.networkError("WebSocket not connected")
        }
        
        let data = try JSONEncoder().encode(request)
        let message = URLSessionWebSocketTask.Message.data(data)
        try await webSocketTask.send(message)
    }
    
    /// Subscribe to updates
    public func subscribe(
        kind: SubscriptionKind,
        filters: [String]
    ) async throws -> WsSubscription {
        let subId = UUID().uuidString
        let request = try WsRequest.subscribe(
            kind: kind,
            subId: subId,
            filters: filters,
            id: getNextRequestId()
        )
        
        let subscription = WsSubscription(
            id: subId,
            kind: kind,
            filters: filters
        )
        
        subscriptions[subId] = subscription
        try await send(request)
        
        return subscription
    }
    
    /// Unsubscribe from updates
    public func unsubscribe(_ subId: String) async throws {
        guard subscriptions[subId] != nil else { return }
        
        let request = try WsRequest.unsubscribe(
            subId: subId,
            id: getNextRequestId()
        )
        
        try await send(request)
        subscriptions.removeValue(forKey: subId)
    }
    
    /// Get message stream
    public func messages() -> AsyncThrowingStream<WsMessage, any Error>? {
        return messageStream
    }
    
    /// Receive messages from WebSocket
    private func receiveMessages() async {
        guard let webSocketTask = webSocketTask else { return }
        
        do {
            while webSocketTask.state == .running {
                let message = try await webSocketTask.receive()
                
                switch message {
                case .data(let data):
                    if let wsMessage = try? WsMessage.decode(from: data) {
                        messageContinuation?.yield(wsMessage)
                    }
                    
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let wsMessage = try? WsMessage.decode(from: data) {
                        messageContinuation?.yield(wsMessage)
                    }
                    
                @unknown default:
                    break
                }
            }
        } catch {
            messageContinuation?.finish(throwing: error)
        }
    }
    
    /// Get next request ID
    private func getNextRequestId() -> Int {
        requestIdCounter += 1
        return requestIdCounter
    }
}

// MARK: - Subscription Management

/// Active WebSocket subscription
public struct WsSubscription: Sendable {
    /// Unique subscription ID
    public let id: String
    
    /// Subscription kind
    public let kind: SubscriptionKind
    
    /// Filters for this subscription
    public let filters: [String]
    
    /// Creation timestamp
    public let createdAt: Date
    
    public init(id: String, kind: SubscriptionKind, filters: [String]) {
        self.id = id
        self.kind = kind
        self.filters = filters
        self.createdAt = Date()
    }
}

// MARK: - Notification Payload Types

/// Helper to decode notification payloads
public struct NotificationPayloadDecoder {
    /// Decode a mint quote response from notification
    public static func decodeMintQuote(from payload: AnyCodable) throws -> MintQuoteResponse {
        guard let dict = payload.dictionaryValue else {
            throw CashuError.deserializationFailed
        }
        
        let data = try JSONSerialization.data(withJSONObject: dict)
        return try JSONDecoder().decode(MintQuoteResponse.self, from: data)
    }
    
    /// Decode a melt quote response from notification
    public static func decodeMeltQuote(from payload: AnyCodable) throws -> PostMeltQuoteResponse {
        guard let dict = payload.dictionaryValue else {
            throw CashuError.deserializationFailed
        }
        
        let data = try JSONSerialization.data(withJSONObject: dict)
        return try JSONDecoder().decode(PostMeltQuoteResponse.self, from: data)
    }
    
    /// Decode a proof state from notification
    public static func decodeProofState(from payload: AnyCodable) throws -> ProofStateInfo {
        guard let dict = payload.dictionaryValue else {
            throw CashuError.deserializationFailed
        }
        
        let data = try JSONSerialization.data(withJSONObject: dict)
        return try JSONDecoder().decode(ProofStateInfo.self, from: data)
    }
}

// MARK: - Mint Info Extensions

/// NUT-17 WebSocket support settings
public struct NUT17Settings: CashuCodabale {
    public let supported: [NUT17MethodSupport]
    
    public init(supported: [NUT17MethodSupport]) {
        self.supported = supported
    }
}

/// WebSocket support for a specific method-unit pair
public struct NUT17MethodSupport: CashuCodabale {
    public let method: String
    public let unit: String
    public let commands: [String]
    
    public init(method: String, unit: String, commands: [String]) {
        self.method = method
        self.unit = unit
        self.commands = commands
    }
    
    /// Check if a specific subscription kind is supported
    public func supports(_ kind: SubscriptionKind) -> Bool {
        return commands.contains(kind.rawValue)
    }
}

extension MintInfo {
    /// Check if the mint supports NUT-17 (WebSockets)
    public var supportsWebSockets: Bool {
        return supportsNUT("17")
    }
    
    /// Get NUT-17 settings if supported
    public func getNUT17Settings() -> NUT17Settings? {
        guard let nut17Data = nuts?["17"]?.dictionaryValue else { return nil }
        
        guard let supportedData = nut17Data["supported"] as? [[String: Any]] else {
            return NUT17Settings(supported: [])
        }
        
        let supported = supportedData.compactMap { supportDict -> NUT17MethodSupport? in
            guard let method = supportDict["method"] as? String,
                  let unit = supportDict["unit"] as? String,
                  let commands = supportDict["commands"] as? [String] else {
                return nil
            }
            
            return NUT17MethodSupport(
                method: method,
                unit: unit,
                commands: commands
            )
        }
        
        return NUT17Settings(supported: supported)
    }
    
    /// Check if mint supports specific WebSocket subscription
    public func supportsWebSocketSubscription(
        kind: SubscriptionKind,
        method: String,
        unit: String
    ) -> Bool {
        guard let settings = getNUT17Settings() else { return false }
        
        return settings.supported.contains { support in
            support.method == method &&
            support.unit == unit &&
            support.supports(kind)
        }
    }
}

// MARK: - CashuWallet Extensions

extension CashuWallet {
    /// Create WebSocket client for this wallet's mint
    @available(iOS 13.0, macOS 10.15, *)
    public func createWebSocketClient() throws -> WebSocketClient {
        // Replace https:// with wss:// or http:// with ws://
        var wsURLString = mintURL
        if wsURLString.hasPrefix("https://") {
            wsURLString = wsURLString.replacingOccurrences(of: "https://", with: "wss://")
        } else if wsURLString.hasPrefix("http://") {
            wsURLString = wsURLString.replacingOccurrences(of: "http://", with: "ws://")
        }
        
        // Append WebSocket path
        wsURLString += "/v1/ws"
        
        guard let wsURL = URL(string: wsURLString) else {
            throw CashuError.invalidMintURL
        }
        
        return WebSocketClient(url: wsURL)
    }
}